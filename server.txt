package main

import (
	"bufio"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/valyala/fasthttp"
)

type User struct {
	Name     string `json:"Name"`
	Password string `json:"Password`
}
type ResponseData struct {
	Token  string `json:"Token"`
	Status string `json:"Status"`
	Type   string `json:"Type"`
	Ip     string `json:"Ip"`
	Mtu    int    `json:"Mtu"`
}

var (
	NameAndPasswordFile = "ServerNameAndPassword.json"
	DataFile            = "data.json"
	MyEncryptKey        = []byte("selamýn-aleyküm-adým-azrail-1")
	MySigningKey        = []byte("MyKey")
	Addr                = flag.String("addr", ":8000", "TCP address to listen to")
	Compress            = flag.Bool("compress", false, "Whether to enable transparent response compression")
)

func main() {
	flag.Parse()

	Handler := RequestHandler
	if *Compress {
		Handler = fasthttp.CompressHandler(Handler)
	}

	if ListenErr := fasthttp.ListenAndServeTLS(*Addr, "MyCertificate.crt", "MyKey.key", Handler); ListenErr != nil {
		log.Fatalf("Error in ListenAndServeTLS: %s", ListenErr)
	}

}

//request handing
func RequestHandler(ctx *fasthttp.RequestCtx) {

	if string(ctx.Path()) == "/login" {
		RequestedNameAndPassword := string(ctx.Request.Body())
		Boolean := CheckNameAndPassword(RequestedNameAndPassword)
		if Boolean {
			Token := CreatToken()
			Message := &ResponseData{Status: "0", Token: Token}

			JSONData, MarshalErr := json.Marshal(Message)
			if MarshalErr != nil {
				log.Println(MarshalErr)
			}

			ctx.SetBodyString(string(JSONData))
		}
		if Boolean == false {
			Message := &ResponseData{Status: "1", Token: ""}

			JSONData, err := json.Marshal(Message)
			if err != nil {
				log.Println(err)
			}

			ctx.SetBodyString(string(JSONData))
		}
	}
	if string(ctx.Path()) == "/token" {
		TokenString := string(ctx.Request.Body())
		fmt.Println(TokenString)
		Message := ParseErrorChecking(TokenString)
		if Message == "expired" {
			Message := &ResponseData{Status: "2", Token: ""}

			JSONData, err := json.Marshal(Message)
			if err != nil {
				log.Println(err)
			}
			ByteArray, _ := Encrypt(JSONData, MyEncryptKey)
			ctx.SetBody(ByteArray)

		}
		if Message == "invalid" {
			Message := &ResponseData{Status: "3", Token: ""}

			JSONData, err := json.Marshal(Message)
			if err != nil {
				log.Println(err)
			}
			ByteArray, _ := Encrypt(JSONData, MyEncryptKey)
			ctx.SetBody(ByteArray)

		}
		if Message == "valid" {
			a := ""
			LocalAddresses()
			for i := 0; i < len(Reader(DataFile)); i++ {
				a = a + (Reader("data.json")[i])

			}
			ByteMessage := []byte(a)
			ByteArray, _ := Encrypt(ByteMessage, MyEncryptKey)
			ctx.SetBody(ByteArray)
			DeleteDataFile()
		}
	}

	ctx.SetContentType("text/plain; charset=utf8")

	// Set arbitrary headers
	ctx.Response.Header.Set("X-My-Header", "my-header-value")

}

//read a file with arg it returns []string
func Reader(fileName string) []string {
	File, OpenFileErr := os.Open(fileName)
	if OpenFileErr != nil {
		log.Fatalf("failed opening file: %s", OpenFileErr)
	}

	Scanner := bufio.NewScanner(File)
	Scanner.Split(bufio.ScanLines)
	var TxtLines []string

	for Scanner.Scan() {
		TxtLines = append(TxtLines, Scanner.Text())
	}

	File.Close()
	return TxtLines
}

//generate a token

func CreatToken() string {
	Data := new(User)
	JSONErr := json.Unmarshal([]byte(Readerr(NameAndPasswordFile)), &Data)

	if JSONErr != nil {
		panic(JSONErr)
	}
	Token := jwt.New(jwt.SigningMethodHS256)
	Claims := Token.Claims.(jwt.MapClaims)
	Claims["user"] = Data.Name
	Claims["exp"] = time.Now().Add(time.Second * 30).Unix()
	TokenString, SigningErr := Token.SignedString(MySigningKey)
	if SigningErr != nil {
		fmt.Errorf("someting went wrong %s", SigningErr)
		return ""
	}
	return TokenString
}

//read a file and return string
func Readerr(fileName string) string {
	File, OpenFileErr := os.Open(fileName)
	if OpenFileErr != nil {
		log.Fatalf("failed opening file: %s", OpenFileErr)
	}

	Scanner := bufio.NewScanner(File)
	Scanner.Split(bufio.ScanLines)
	var TxtLines []string

	for Scanner.Scan() {
		TxtLines = append(TxtLines, Scanner.Text())
	}

	File.Close()
	return TxtLines[0]
}

//check name and password which is comng from client and in server base
func CheckNameAndPassword(RequestName string) bool {
	nameAndPassword := Readerr(NameAndPasswordFile)
	if nameAndPassword == RequestName {
		return true
	}
	return false
}

//parse a token and return valid expired and invalid
func ParseErrorChecking(tokenString1 string) string {
	// Token from another example.  This token is expired

	Token, ParseErr := jwt.Parse(tokenString1, func(token *jwt.Token) (interface{}, error) {
		return []byte(MySigningKey), nil
	})
	if ParseErr != nil {
		return "invalid"
	}
	if Token.Valid == true {
		return "valid"
	} else if ValidationError, boolOk := ParseErr.(*jwt.ValidationError); boolOk {
		if ValidationError.Errors&jwt.ValidationErrorMalformed != 0 {
			return "invalid"
		} else if ValidationError.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
			// Token is either expired or not active yet
			return "expired"
		} else {
			return "Couldn't handle this token"
		}
	} else {
		return "Couldn't handle this token"
	}

}

//it gives interfaces ip and mtu
func LocalAddresses() {
	CreateDataFile()
	List, InterfacesErr := net.Interfaces()
	if InterfacesErr != nil {
		panic(InterfacesErr)
	}

	for _, Iface := range List {
		Addrs, AddersErr := Iface.Addrs()
		if AddersErr != nil {
			panic(AddersErr)
		}

		for _, Addr := range Addrs {
			if IsIPv4(Addr.String()) == true {
				ResponseMessage := &ResponseData{
					Type:   Iface.Name,
					Status: "4",
					Mtu:    Iface.MTU,
					Ip:     Addr.String(),
				}

				Result, MarshalErr := json.Marshal(ResponseMessage)
				if MarshalErr != nil {
					panic(MarshalErr)
				}
				fmt.Println(string(Result))
				WriteDataJSON(string(Result) + "?")
			}

		}

	}
}

//it writes data whic is sending to client
func WriteDataJSON(data string) {
	File, OpenFileErr := os.OpenFile(DataFile,
		os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if OpenFileErr != nil {
		log.Println(OpenFileErr)
	}
	defer File.Close()
	if _, WriteErr := File.WriteString(data); WriteErr != nil {
		log.Println(WriteErr)
	}
}

//err printer
func IsError(err error) bool {
	if err != nil {
		fmt.Println(err.Error())
	}

	return (err != nil)
}

//it is creating a data.json file for a request
func CreateDataFile() {
	// check if file exists
	var _, StatErr = os.Stat(DataFile)

	// create file if not exists
	if os.IsNotExist(StatErr) {
		var File, CreatErr = os.Create(DataFile)
		if IsError(CreatErr) {
			return
		}
		defer File.Close()
	}

}

//delete data.json file
func DeleteDataFile() {
	var RemoveErr = os.Remove(DataFile)
	if IsError(RemoveErr) {
		return
	}
}

//encrypt to data for send to client
func Encrypt(plaintext []byte, key []byte) ([]byte, error) {
	Chip, NewChiperErr := aes.NewCipher(key)
	if NewChiperErr != nil {
		return nil, NewChiperErr
	}

	Gcm, NewGcmErr := cipher.NewGCM(Chip)
	if NewGcmErr != nil {
		return nil, NewGcmErr
	}

	Nonce := make([]byte, Gcm.NonceSize())
	if _, ReadFullErr := io.ReadFull(rand.Reader, Nonce); ReadFullErr != nil {
		return nil, ReadFullErr
	}

	return Gcm.Seal(Nonce, Nonce, plaintext, nil), nil
}
func IsIPv4(address string) bool {
	return strings.Count(address, ":") < 2
}
